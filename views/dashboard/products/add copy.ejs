<div class="dashboard-header-row">
  <h2 class="dashboard-title">Thêm sản phẩm</h2>
</div>

<form id="addProductForm" novalidate>
  <div class="add-product-container">
    <div class="product-form-column">
      <div class="form-section">
        <h3 class="section-title">Thông tin sản phẩm</h3>
        <div class="form-row">
          <div class="form-group">
            <label for="productName">Tên sản phẩm</label>
            <input type="text" id="productName" class="form-control" placeholder="Nhập tên sản phẩm" />
            <div class="invalid-feedback"></div>
          </div>
          <div class="form-group">
            <label for="productSlug">Slug</label>
            <input type="text" id="productSlug" class="form-control" placeholder="Có thể tự tạo nếu bỏ trống" />
            <div class="invalid-feedback"></div>
          </div>
          <div class="form-group">
            <label for="productStatus">Trạng thái</label>
            <div class="select-wrapper">
              <select id="productStatus" class="form-control">
                <option value="">Chọn trạng thái</option>
                <option value="1">Hiển thị</option>
                <option value="0">Ẩn</option>
              </select>
              <i class="fas fa-chevron-down"></i>
            </div>
            <div class="invalid-feedback"></div>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label for="productCategory">Danh mục</label>
            <div class="select-wrapper">
              <select id="productCategory" class="form-control">
                <option value="">Chọn danh mục</option>
              </select>
              <i class="fas fa-chevron-down"></i>
            </div>
            <div class="invalid-feedback"></div>
          </div>
          <div class="form-group">
            <label for="productRooms">Danh mục phòng</label>
            <div class="select-wrapper">
              <select id="productRooms" class="form-control">
                <option value="">Chọn phòng</option>
              </select>
              <i class="fas fa-chevron-down"></i>
            </div>
            <div class="invalid-feedback"></div>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group full-width">
            <label for="productDescription">Mô tả</label>
            <textarea id="productDescription" class="form-control" rows="5" placeholder="Nhập mô tả"></textarea>
            <div class="invalid-feedback"></div>
          </div>
        </div>
      </div>
      <div class="form-section">
        <h3 class="section-title">Thông tin bổ sung</h3>
        <div id="dynamicAttributesContainer"></div>
      </div>
    </div>
    <div class="right-column">
      <div class="form-section">
        <h3 class="section-title">Ảnh chính sản phẩm</h3>
        <div class="main-image-upload">
          <div class="upload-zone" id="mainImageUpload">
            <i class="fas fa-cloud-upload-alt"></i>
            <p>Kéo thả hoặc click để tải ảnh</p>
            <p class="upload-hint">Định dạng: JPG, PNG (Tối đa 5MB)</p>
            <input type="file" id="mainImageFile" accept="image/*" hidden />
          </div>
          <div class="main-image-preview" style="display: none">
            <img src="" alt="Preview" />
            <button class="remove-image"><i class="fas fa-times"></i></button>
          </div>
        </div>
      </div>
      <div class="form-section">
        <div class="variant-header">
          <h3 class="section-title">Biến thể sản phẩm</h3>
          <button type="button" class="btn btn-add-variant">
            <i class="fas fa-plus"></i> Thêm biến thể
          </button>
        </div>
        <div id="variantsList">
          <!-- Template biến thể -->
          <div class="variant-item" style="display: none" id="variantTemplate">
            <div class="variant-header">
              <h4 class="variant-title">Biến thể mới</h4>
              <div class="variant-actions">
                <button class="btn-toggle-variant">
                  <i class="fas fa-chevron-down"></i>
                  <i class="fas fa-chevron-up"></i>
                </button>
                <button class="btn-remove-variant">
                  <i class="fas fa-trash"></i>
                </button>
              </div>
            </div>
            <div class="variant-content">
              <div class="form-row">
                <div class="form-group">
                  <label>Tên màu</label>
                  <div class="select-wrapper">
                    <select class="form-control variant-color">
                      <option value="">Chọn màu</option>
                    </select>
                    <i class="fas fa-chevron-down"></i>
                  </div>
                  <div class="invalid-feedback"></div>
                </div>
                <div class="form-group">
                  <label>Slug</label>
                  <input type="text" class="form-control variant-slug" placeholder="Tự động tạo nếu để trống" />
                  <div class="invalid-feedback"></div>
                </div>
              </div>
              <div class="form-row">
                <div class="form-group">
                  <label>Số lượng</label>
                  <input type="number" class="form-control variant-quantity" min="0" placeholder="Nhập số lượng" />
                  <div class="invalid-feedback"></div>
                </div>
                <div class="form-group">
                  <label>Giá gốc</label>
                  <input type="number" class="form-control variant-price" min="0" placeholder="Nhập giá gốc" />
                  <div class="invalid-feedback"></div>
                </div>
                <div class="form-group">
                  <label>Giá giảm</label>
                  <input type="number" class="form-control variant-sale-price" min="0" placeholder="Nhập giá giảm" />
                </div>
              </div>
              <div class="variant-images">
                <label>Hình ảnh biến thể</label>
                <div class="variant-image-grid">
                  <div class="variant-image-item active">
                    <div class="upload-placeholder">
                      <i class="fas fa-plus"></i>
                      <input type="file" accept="image/*" />
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <!-- end template -->
        </div>
      </div>
    </div>
  </div>
  <div class="form-actions">
    <button type="button" class="btn btn-cancel">Hủy</button>
    <button type="button" class="btn btn-save">Lưu</button>
  </div>
</form>

<script>
  const API_URL = "http://localhost:3501/api";

  // Global variables (now managed by ProductFormManager instance)
  let allColors = [];
  let allMaterials = [];

  // Utility Functions
  function showToast(message, type = "success") {
    let toastContainer = document.getElementById("toastContainer");
    if (!toastContainer) {
      toastContainer = document.createElement("div");
      toastContainer.id = "toastContainer";
      toastContainer.className = "position-fixed top-0 end-0 p-3";
      toastContainer.style.zIndex = "1050";
      document.body.appendChild(toastContainer);
    }

    const toast = document.createElement("div");
    toast.className = `toast align-items-center text-white bg-${type} border-0`;
    toast.setAttribute("role", "alert");
    toast.setAttribute("aria-live", "assertive");
    toast.setAttribute("aria-atomic", "true");

    toast.innerHTML = `
            <div class="d-flex">
                <div class="toast-body" style="font-size: 24px;">${message}</div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
        `;

    toastContainer.appendChild(toast);
    const bsToast = new bootstrap.Toast(toast, { delay: 3000 });
    bsToast.show();

    toast.addEventListener("hidden.bs.toast", () => toast.remove());
  }

  async function uploadImage(file, folder = "", subfolder = "") {
    console.log(`[uploadImage] Attempting to upload file: ${file ? file.name : 'No file'} to folder: ${folder}/${subfolder}`);
    if (!file) return null;
    const formData = new FormData();
    formData.append("image", file);
    formData.append("folder", folder);
    if (subfolder) formData.append("subfolder", subfolder);

    try {
      const res = await fetch(`${API_URL}/upload/product`, {
        method: "POST",
        body: formData,
      });
      const data = await res.json();
      if (!res.ok) {
        console.error(`[uploadImage] Server error response:`, data);
        throw new Error(data.message || `Server responded with ${res.status}`);
      }
      console.log(`[uploadImage] Upload successful, URL: ${data.url}`);
      return data.url || null;
    } catch (error) {
      console.error("[uploadImage] Error uploading image:", error);
      showToast("Lỗi khi tải ảnh lên: " + error.message, "danger");
      return null;
    }
  }

  function generateSlug(str) {
    return str
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/[đĐ]/g, "d")
      .replace(/[^a-z0-9]/g, "-")
      .replace(/-+/g, "-")
      .replace(/^-+|-+$/g, "");
  }

  async function fetchAPI(endpoint) {
    console.log(`[fetchAPI] Fetching from: ${API_URL}${endpoint}`);
    try {
      const response = await fetch(`${API_URL}${endpoint}`);
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[fetchAPI] Network response not ok: ${response.status} ${response.statusText} - ${errorText}`);
        throw new Error(
          `Network response was not ok: ${response.status} ${response.statusText} - ${errorText}`
        );
      }
      const data = await response.json();
      console.log(`[fetchAPI] Data received from ${endpoint}:`, data);
      return data;
    } catch (error) {
      console.error("[fetchAPI] Error fetching from " + endpoint + ":", error);
      showToast("Lỗi khi tải dữ liệu: " + error.message, "danger");
      return null;
    }
  }

  // --- ProductFormManager Class ---
  class ProductFormManager {
    constructor() {
      console.log("[ProductFormManager] Constructor called.");
      this.elements = {
        productName: document.getElementById("productName"),
        productSlug: document.getElementById("productSlug"),
        productStatus: document.getElementById("productStatus"),
        productCategory: document.getElementById("productCategory"),
        productRooms: document.getElementById("productRooms"),
        productDescription: document.getElementById("productDescription"),
        dynamicAttributesContainer: document.getElementById("dynamicAttributesContainer"),
        mainImageUploadZone: document.getElementById("mainImageUpload"),
        mainImageFileInput: document.getElementById("mainImageFile"),
        mainImagePreviewContainer: document.querySelector(".main-image-preview"),
        mainImagePreviewImg: document.querySelector(".main-image-preview img"),
        removeMainImageBtn: document.querySelector(".main-image-preview .remove-image"),
        variantsList: document.getElementById("variantsList"),
        variantTemplate: document.getElementById("variantTemplate"),
        addVariantBtn: document.querySelector(".btn-add-variant"),
        saveButton: document.querySelector(".btn-save"),
        cancelButton: document.querySelector(".btn-cancel"),
      };

      this.mainImageFile = null; // Store the actual file object
      this.variantImageCounters = new Map(); // Store image counts for each variant element
      this.validationErrors = []; // To store validation errors

      this.setupEventListeners();
    }

    setupEventListeners() {
      console.log("[ProductFormManager] Setting up event listeners.");
      // Main Product Info
      if (this.elements.productName) {
        this.elements.productName.addEventListener("input", () => this.handleProductNameInput());
      }
      if (this.elements.productCategory) {
        this.elements.productCategory.addEventListener("change", () => this.handleCategoryChange());
      }
      if (this.elements.cancelButton) {
        this.elements.cancelButton.addEventListener("click", () => this.handleCancel());
      }

      // Main Image Upload
      if (this.elements.mainImageUploadZone) {
        this.elements.mainImageUploadZone.addEventListener("click", () => {
          console.log("[MainImage] Upload zone clicked, triggering file input.");
          this.elements.mainImageFileInput.click();
        });
      }
      if (this.elements.mainImageFileInput) {
        this.elements.mainImageFileInput.addEventListener("change", (e) => this.handleMainImageFileSelect(e));
      }
      if (this.elements.removeMainImageBtn) {
        // Add event parameter to prevent default behavior
        this.elements.removeMainImageBtn.addEventListener("click", (e) => this.handleRemoveMainImage(e));
      }

      // Add Variant Button
      if (this.elements.addVariantBtn) {
        this.elements.addVariantBtn.addEventListener("click", () => this.addVariant());
      }

      // Save Button
      if (this.elements.saveButton) {
        // Add event parameter to prevent default behavior
        this.elements.saveButton.addEventListener("click", (e) => this.handleSave(e));
      }

      // General validation clearing on input/change
      document.addEventListener("input", (e) => this.clearValidationError(e.target));
      document.addEventListener("change", (e) => this.clearValidationError(e.target));
    }

    async initializeForm() {
      console.log("[ProductFormManager] Initializing form data.");
      try {
        await Promise.all([
          this.loadSelectData("productCategory", "/categories", "category_id", "category_name", "Chọn danh mục"),
          this.loadSelectData("productRooms", "/rooms/filter", "room_id", "room_name", "Chọn phòng"),
          this.loadAllMaterials(),
          this.loadAllColors(), // Load all colors once
        ]);

        // Load attributes if a category is already selected (e.g., on edit page)
        if (this.elements.productCategory && this.elements.productCategory.value) {
          console.log(`[ProductFormManager] Category selected on init: ${this.elements.productCategory.value}, loading attributes.`);
          this.loadCategoryAttributes(this.elements.productCategory.value);
        }

      } catch (error) {
        console.error("[ProductFormManager] Error initializing form:", error);
        showToast("Lỗi khởi tạo form", "danger");
      }
    }

    // --- Handlers for main product info ---
    handleProductNameInput() {
      console.log("[ProductName] Input changed.");
      const slug = generateSlug(this.elements.productName.value);
      this.elements.productSlug.value = slug;
    }

    handleCategoryChange() {
      console.log(`[Category] Selected category changed to: ${this.elements.productCategory.value}`);
      this.loadCategoryAttributes(this.elements.productCategory.value);
    }

    handleCancel() {
      console.log("[CancelButton] Clicked, redirecting.");
      window.location.href = "/dashboard/products";
    }

    // --- Main Image Upload Logic ---
    handleMainImageFileSelect(e) {
      const file = e.target.files[0];
      console.log(`[MainImage] File selected: ${file ? file.name : 'None'}`);
      if (file && file.type.startsWith("image/")) {
        this.mainImageFile = file; // Store the actual file
        const reader = new FileReader();
        reader.onload = (readerEvent) => {
          this.elements.mainImagePreviewImg.src = readerEvent.target.result;
          this.elements.mainImagePreviewContainer.style.display = "block";
          this.elements.mainImageUploadZone.style.display = "none";
          console.log("[MainImage] Preview displayed, upload zone hidden.");
          this.clearSpecificValidationError(this.elements.mainImageUploadZone);
        };
        reader.readAsDataURL(file);
      } else {
        this.mainImageFile = null; // Reset if invalid file selected
        this.elements.mainImageFileInput.value = ""; // Clear file input
        this.elements.mainImagePreviewContainer.style.display = "none";
        this.elements.mainImageUploadZone.style.display = "block";
        console.log("[MainImage] Invalid file selected or no file, showing upload zone.");
        this.addValidationError(this.elements.mainImageUploadZone, "Vui lòng chọn một file ảnh hợp lệ.");
      }
    }

    handleRemoveMainImage(e) { // Added event parameter
      e.preventDefault(); // Prevent default button behavior (e.g., form submission)
      console.log("[MainImage] Removing main image. Before: mainImageFile is", this.mainImageFile);
      this.elements.mainImagePreviewContainer.style.display = "none";
      this.elements.mainImageUploadZone.style.display = "block";
      this.elements.mainImageFileInput.value = ""; // Clear file input
      this.mainImageFile = null; // Clear stored file
      console.log("[MainImage] Main image removed. After: mainImageFile is", this.mainImageFile);
      this.clearSpecificValidationError(this.elements.mainImageUploadZone); // Clear any associated validation error
    }

    // --- Variant Image Upload Logic ---
    setupVariantImageUpload(variantElement) {
      const imageGrid = variantElement.querySelector(".variant-image-grid");
      const maxImages = 7;
      console.log(`[VariantImageUpload] Setting up for variant: ${variantElement.id}. Initializing counter.`);

      // Initialize or reset counter for this specific variant
      this.variantImageCounters.set(variantElement, 0);

      // Clear existing image boxes when setting up a variant (important for cloned templates)
      imageGrid.innerHTML = '';

      // Function to create a new empty image box
      const createImageBox = () => {
        console.log(`[VariantImageUpload:${variantElement.id}] Creating new image box.`);
        const div = document.createElement("div");
        div.className = "variant-image-item active"; // 'active' means it's an upload slot
        div.innerHTML = `
                    <div class="upload-placeholder">
                        <i class="fas fa-plus"></i>
                        <input type="file" hidden accept="image/*">
                    </div>
                `;
        return div;
      };

      // Function to set up event listeners for an image box
      const setupImageBox = (imageBox) => {
        const input = imageBox.querySelector('input[type="file"]');
        const placeholder = imageBox.querySelector(".upload-placeholder");

        imageBox.addEventListener("click", () => {
          console.log(`[VariantImageUpload:${variantElement.id}] Image box clicked, triggering file input.`);
          input.click();
        });

        input.addEventListener("change", (e) => {
          const file = e.target.files[0];
          console.log(`[VariantImageUpload:${variantElement.id}] File selected for box. File: ${file ? file.name : 'None'}`);
          if (file && file.type.startsWith("image/")) {
            const reader = new FileReader();
            reader.onload = (readerEvent) => {
              imageBox.classList.add("loaded");
              imageBox.classList.remove("active"); // No longer an active upload slot

              placeholder.style.display = "none"; // Hide the plus icon

              // Display the image preview
              const img = document.createElement("img");
              img.src = readerEvent.target.result;
              img.alt = "Preview";
              imageBox.appendChild(img);

              // Add a remove button
              const removeBtn = document.createElement("button");
              removeBtn.className = "remove-image";
              removeBtn.innerHTML = `<i class="fas fa-times"></i>`;
              imageBox.appendChild(removeBtn);

              // Handle image removal for this specific image box
              removeBtn.addEventListener("click", (removeEvent) => {
                removeEvent.preventDefault(); // Prevent default button behavior
                removeEvent.stopPropagation(); // Prevent click from bubbling to imageBox and re-opening file input
                console.log(`[VariantImageUpload:${variantElement.id}] Removing image from box.`);
                imageBox.remove(); // Remove the image box from the DOM

                // Decrement the count for this variant
                this.variantImageCounters.set(variantElement, this.variantImageCounters.get(variantElement) - 1);
                console.log(`[VariantImageUpload:${variantElement.id}] Image removed. Current count: ${this.variantImageCounters.get(variantElement)}`);

                // If there are no active upload boxes AND we are below maxImages, add a new empty upload box.
                const currentLoadedImages = imageGrid.querySelectorAll('.variant-image-item.loaded').length;
                const currentActiveBoxes = imageGrid.querySelectorAll('.variant-image-item.active').length;
                console.log(`[VariantImageUpload:${variantElement.id}] Loaded images: ${currentLoadedImages}, Active boxes: ${currentActiveBoxes}`);

                if (currentActiveBoxes === 0 && currentLoadedImages < maxImages) {
                  console.log(`[VariantImageUpload:${variantElement.id}] Adding new empty upload box after removal.`);
                  const newBox = createImageBox();
                  imageGrid.appendChild(newBox);
                  setupImageBox(newBox);
                }
                // Clear validation feedback for the grid if images now meet requirement
                this.clearSpecificValidationError(imageGrid);
              });

              // Increment image count for this specific variant
              this.variantImageCounters.set(variantElement, this.variantImageCounters.get(variantElement) + 1);
              console.log(`[VariantImageUpload:${variantElement.id}] Image loaded. Current count: ${this.variantImageCounters.get(variantElement)}`);

              // After an image is successfully loaded, if we haven't reached maxImages,
              // add a new empty image box for the next upload.
              if (this.variantImageCounters.get(variantElement) < maxImages && imageGrid.querySelectorAll('.variant-image-item.active').length === 0) {
                console.log(`[VariantImageUpload:${variantElement.id}] Adding new empty upload box after successful upload.`);
                const newBox = createImageBox();
                imageGrid.appendChild(newBox);
                setupImageBox(newBox);
              }

              // Clear validation feedback if this action resolves the error
              this.clearSpecificValidationError(imageGrid);
            };
            reader.readAsDataURL(file);
          } else {
            // If an invalid file is selected, clear the input and show error
            e.target.value = '';
            console.warn(`[VariantImageUpload:${variantElement.id}] Invalid file type selected.`);
            showToast("Vui lòng chọn một file ảnh hợp lệ.", "danger");
          }
        });
      };

      // Add the initial empty image box for upload
      const firstBox = createImageBox();
      imageGrid.appendChild(firstBox);
      setupImageBox(firstBox);
    }


    // --- Variant Management Logic ---
    addVariant() {
      console.log("[AddVariant] Button clicked.");
      const visibleVariants = [...document.querySelectorAll(".variant-item")].filter(
        (v) => v.style.display !== "none" && v.id !== "variantTemplate"
      );
      const newIndex = visibleVariants.length;

      const newVariant = this.elements.variantTemplate.cloneNode(true);
      newVariant.id = `variant-${newIndex + 1}`;
      newVariant.style.display = "block";
      newVariant.classList.add("is-expanded"); // Add for initial expansion
      newVariant.querySelector(".variant-title").textContent = `Biến thể ${newIndex + 1}`;
      console.log(`[AddVariant] New variant created: ${newVariant.id}`);

      // Reset validation states on cloned element
      newVariant.querySelectorAll(".is-invalid").forEach((el) => el.classList.remove("is-invalid"));
      newVariant.querySelectorAll(".invalid-feedback").forEach((el) => (el.textContent = ""));

      // Populate colors for the new variant's color select
      const newVariantColorSelect = newVariant.querySelector(".variant-color");
      if (newVariantColorSelect && allColors.length > 0) {
        newVariantColorSelect.innerHTML = `
                    <option value="">Chọn màu</option>
                    ${allColors.map(color => `
                        <option value="${color.color_id}" data-hex="${color.color_hex}">
                            ${color.color_name}
                        </option>
                    `).join("")}
                `;
        console.log(`[AddVariant:${newVariant.id}] Populated color options.`);
      }

      this.setupVariantEvents(newVariant);
      this.elements.variantsList.appendChild(newVariant);

      // Ensure content expands with transition for newly added variant
      const content = newVariant.querySelector(".variant-content");
      if (content) {
        content.style.display = 'block';
        requestAnimationFrame(() => {
          content.style.maxHeight = content.scrollHeight + "px";
          console.log(`[AddVariant:${newVariant.id}] Setting initial maxHeight for transition: ${content.scrollHeight}px`);
          content.addEventListener('transitionend', function handler() {
            content.style.maxHeight = 'none'; // Allow dynamic height after transition
            console.log(`[AddVariant:${newVariant.id}] Transition ended, maxHeight set to 'none'.`);
            content.removeEventListener('transitionend', handler);
          }, { once: true });
        });
      }
    }

    setupVariantEvents(variantElement) {
      const toggleButton = variantElement.querySelector(".btn-toggle-variant");
      const content = variantElement.querySelector(".variant-content");
      console.log(`[VariantEvents] Setting up events for variant: ${variantElement.id}`);

      // Initial state for toggle button (assuming template is hidden by default)
      if (variantElement.style.display === "block" && variantElement.classList.contains("is-expanded")) {
        toggleButton.querySelector(".fa-chevron-down").style.display = "none";
        toggleButton.querySelector(".fa-chevron-up").style.display = "inline-block";
        console.log(`[VariantEvents:${variantElement.id}] Initial state: Expanded.`);
      } else {
        toggleButton.querySelector(".fa-chevron-down").style.display = "inline-block";
        toggleButton.querySelector(".fa-chevron-up").style.display = "none";
        console.log(`[VariantEvents:${variantElement.id}] Initial state: Collapsed.`);
      }

      // Toggle logic for variant content
      if (toggleButton) {
        toggleButton.addEventListener("click", () => {
          const isExpanded = variantElement.classList.contains('is-expanded');
          console.log(`[VariantEvents:${variantElement.id}] Toggle button clicked. Currently expanded: ${isExpanded}`);
          if (isExpanded) {
            content.style.maxHeight = content.scrollHeight + "px"; // Set explicit height before transition
            requestAnimationFrame(() => {
              content.style.maxHeight = "0";
              variantElement.classList.remove("is-expanded");
              console.log(`[VariantEvents:${variantElement.id}] Collapsing variant.`);
            });
            content.addEventListener('transitionend', function handler() {
              content.style.display = 'none';
              toggleButton.querySelector(".fa-chevron-down").style.display = "inline-block";
              toggleButton.querySelector(".fa-chevron-up").style.display = "none";
              console.log(`[VariantEvents:${variantElement.id}] Collapsed transition ended, display none.`);
              content.removeEventListener('transitionend', handler);
            }, { once: true });
          } else {
            content.style.display = 'block';
            content.style.maxHeight = "0"; // Ensure starting from 0 for transition
            requestAnimationFrame(() => {
              content.style.maxHeight = content.scrollHeight + "px";
              variantElement.classList.add("is-expanded");
              console.log(`[VariantEvents:${variantElement.id}] Expanding variant.`);
            });
            content.addEventListener('transitionend', function handler() {
              content.style.maxHeight = 'none'; // Allow dynamic height after transition
              toggleButton.querySelector(".fa-chevron-down").style.display = "none";
              toggleButton.querySelector(".fa-chevron-up").style.display = "inline-block";
              console.log(`[VariantEvents:${variantElement.id}] Expanded transition ended, maxHeight none.`);
              content.removeEventListener('transitionend', handler);
            }, { once: true });
          }
        });
      }

      // Remove variant
      const removeButton = variantElement.querySelector(".btn-remove-variant");
      if (removeButton) {
        removeButton.addEventListener("click", (e) => { // Added event parameter
          e.preventDefault(); // Prevent default button behavior
          console.log(`[VariantEvents:${variantElement.id}] Remove button clicked.`);
          if (confirm("Bạn có chắc muốn xóa biến thể này?")) {
            console.log(`[VariantEvents:${variantElement.id}] Confirming removal.`);
            variantElement.remove();
            this.variantImageCounters.delete(variantElement); // Remove counter entry
            console.log(`[VariantEvents:${variantElement.id}] Variant removed from DOM and counter map.`);
          } else {
            console.log(`[VariantEvents:${variantElement.id}] Removal cancelled.`);
          }
        });
      }

      // Auto-generate slug on color select
      const colorSelect = variantElement.querySelector(".variant-color");
      const slugInput = variantElement.querySelector(".variant-slug");
      if (colorSelect && slugInput) {
        colorSelect.addEventListener("change", () => {
          console.log(`[VariantEvents:${variantElement.id}] Color select changed.`);
          const selectedOption = colorSelect.options[colorSelect.selectedIndex];
          const colorName = selectedOption?.textContent?.trim() || "";
          if (colorName && !slugInput.value) {
            slugInput.value = generateSlug(colorName);
            console.log(`[VariantEvents:${variantElement.id}] Slug generated: ${slugInput.value}`);
          }
        });
      }

      // Setup image upload for this specific variant
      this.setupVariantImageUpload(variantElement);
    }

    // --- Data Loading Functions ---
    async loadSelectData(selectId, endpoint, valueKey, textKey, placeholder = "Chọn...") {
      const select = this.elements[selectId];
      console.log(`[LoadData] Loading data for ${selectId} from ${endpoint}`);
      if (!select) {
        console.warn(`[LoadData] Select element with ID '${selectId}' not found.`);
        return;
      }

      try {
        const data = await fetchAPI(endpoint);
        if (!data || !Array.isArray(data)) {
          throw new Error("Dữ liệu không hợp lệ hoặc rỗng");
        }

        select.innerHTML =
          `<option value="">${placeholder}</option>` +
          data
            .map((item) => `<option value="${item[valueKey]}">${item[textKey]}</option>`)
            .join("");
        console.log(`[LoadData] Successfully loaded data for ${selectId}.`);
      } catch (error) {
        console.error(`[LoadData] Error loading ${selectId}:`, error);
        select.innerHTML = `<option value="">Lỗi tải dữ liệu</option>`;
        showToast(`Lỗi khi tải dữ liệu cho ${placeholder}: ${error.message}`, "danger");
      }
    }

    async loadAllColors() {
      console.log("[LoadData] Loading all colors.");
      try {
        const colors = await fetchAPI("/color/filter");
        if (!colors || !Array.isArray(colors)) {
          throw new Error("Dữ liệu màu không hợp lệ");
        }
        allColors = colors; // Store globally for new variants
        console.log("[LoadData] All colors loaded:", allColors);
      } catch (error) {
        console.error("[LoadData] Error loading colors:", error);
        showToast("Lỗi khi tải dữ liệu màu sắc", "danger");
      }
    }

    async loadAllMaterials() {
      console.log("[LoadData] Loading all materials.");
      try {
        const materials = await fetchAPI("/materials");
        if (!materials || !Array.isArray(materials)) {
          throw new Error("Dữ liệu chất liệu không hợp lệ");
        }
        allMaterials = materials;
        console.log("[LoadData] All materials loaded:", allMaterials);
      } catch (error) {
        console.error("[LoadData] Error loading all materials:", error);
        showToast("Lỗi khi tải danh sách chất liệu.", "danger");
      }
    }

    async loadCategoryAttributes(categoryId) {
      const container = this.elements.dynamicAttributesContainer;
      container.innerHTML = "";
      console.log(`[LoadData] Loading category attributes for categoryId: ${categoryId}`);

      if (!categoryId) {
        console.log("[LoadData] No categoryId provided, skipping attribute load.");
        return;
      }

      try {
        const attributes = await fetchAPI(`/categories/${categoryId}`);
        if (!attributes || !Array.isArray(attributes) || attributes.length === 0) {
          showToast("Không tìm thấy thuộc tính cho danh mục này.", "info");
          console.log("[LoadData] No attributes found for this category.");
          return;
        }

        let formRowsHtml = "";
        let currentFormRow = '<div class="form-row">';
        let attributesInCurrentRow = 0;

        for (const attr of attributes) {
          const isRequired = attr.is_required ? "required" : "";
          const requiredAsterisk = attr.is_required ? '<span class="text-danger">*</span>' : "";
          let inputHtml = "";

          if (attr.attribute_name.toLowerCase().includes("chất liệu")) {
            const materialOptions = allMaterials.map(
              (mat) => `<option value="${mat.material_id}">${mat.material_name}</option>`
            ).join("");
            inputHtml = `
                            <div class="select-wrapper">
                                <select id="attr-${attr.attribute_id}" class="form-control dynamic-attribute" data-attribute-id="${attr.attribute_id}" data-value-type="material_id" ${isRequired}>
                                    <option value=""> ${attr.attribute_name}</option>
                                    ${materialOptions}
                                </select>
                                <i class="fas fa-chevron-down"></i>
                            </div>
                        `;
          } else if (attr.unit) {
            inputHtml = `
                            <input type="number" id="attr-${attr.attribute_id}" class="form-control dynamic-attribute" data-attribute-id="${attr.attribute_id}" data-value-type="value" placeholder="Nhập ${attr.attribute_name}" ${isRequired} />
                        `;
          } else {
            inputHtml = `
                            <input type="text" id="attr-${attr.attribute_id}" class="form-control dynamic-attribute" data-attribute-id="${attr.attribute_id}" data-value-type="value" placeholder="Nhập ${attr.attribute_name}" ${isRequired} />
                        `;
          }
          currentFormRow += `
                        <div class="form-group form-infor">
                            <label for="attr-${attr.attribute_id}">${attr.attribute_name} ${attr.unit ? `(${attr.unit})` : ""}${requiredAsterisk}</label>
                            ${inputHtml}
                            <div class="invalid-feedback"></div>
                        </div>
                    `;
          attributesInCurrentRow++;

          if (attributesInCurrentRow % 2 === 0 || attributesInCurrentRow === attributes.length) {
            currentFormRow += "</div>";
            formRowsHtml += currentFormRow;
            currentFormRow = '<div class="form-row">';
            attributesInCurrentRow = 0;
          }
        }
        container.innerHTML = formRowsHtml;
        console.log("[LoadData] Dynamic attributes rendered.");
      } catch (error) {
        console.error("[LoadData] Error loading category attributes:", error);
        showToast("Lỗi khi tải thuộc tính danh mục: " + error.message, "danger");
      }
    }


    // --- Validation Logic ---
    addValidationError(element, message) {
      console.log(`[Validation] Adding error for element: ${element.id || element.className}, Message: "${message}"`);
      element.classList.add("is-invalid");
      let feedbackEl;

      // Handle specific cases for elements not inside .form-group
      if (element.id === "mainImageUpload") {
        feedbackEl = element.nextElementSibling; // Might be a temporary feedback div
        if (!feedbackEl || !feedbackEl.classList.contains("invalid-feedback")) {
          feedbackEl = document.createElement("div");
          feedbackEl.className = "invalid-feedback d-block";
          element.parentNode.insertBefore(feedbackEl, element.nextSibling);
        }
      } else if (element.classList.contains("variant-image-grid")) {
        feedbackEl = element.nextElementSibling; // Might be a temporary feedback div
        if (!feedbackEl || !feedbackEl.classList.contains("invalid-feedback")) {
          feedbackEl = document.createElement("div");
          feedbackEl.className = "invalid-feedback d-block";
          element.parentNode.insertBefore(feedbackEl, element.nextSibling);
        }
      } else {
        feedbackEl = element.closest(".form-group")?.querySelector(".invalid-feedback");
      }

      if (feedbackEl) feedbackEl.textContent = message;
      this.validationErrors.push({ element, message });
      console.log("[Validation] Current validationErrors array:", this.validationErrors);
    }

    clearAllValidationErrors() {
      console.log("[Validation] Clearing all validation errors.");
      document.querySelectorAll(".is-invalid").forEach((el) => el.classList.remove("is-invalid"));
      document.querySelectorAll(".invalid-feedback").forEach((el) => el.remove()); // Remove dynamic feedback divs
      this.validationErrors = []; // Reset stored errors
    }

    clearValidationError(element) {
      // console.log(`[Validation] Attempting to clear error for: ${element.id || element.className}`);
      if (element.classList.contains("is-invalid")) {
        element.classList.remove("is-invalid");
        const feedback = element.closest(".form-group")?.querySelector(".invalid-feedback");
        if (feedback) feedback.textContent = "";
      }
      // Specific clear for main image upload zone
      if (element.id === "mainImageFile") {
        const mainImageUploadZone = this.elements.mainImageUploadZone;
        mainImageUploadZone.classList.remove("is-invalid");
        const feedback = mainImageUploadZone.nextElementSibling;
        if (feedback && feedback.classList.contains("invalid-feedback")) {
          feedback.remove();
        }
        console.log("[Validation] Cleared main image upload error.");
      }
      // Specific clear for variant image grids
      if (element.matches('.variant-image-item input[type="file"]')) {
        const variantImageGrid = element.closest(".variant-image-grid");
        if (variantImageGrid) {
          // Check if there's at least one loaded image to clear the error
          const currentImages = variantImageGrid.querySelectorAll(".variant-image-item.loaded").length;
          if (currentImages > 0) {
            variantImageGrid.classList.remove("is-invalid");
            const feedback = variantImageGrid.nextElementSibling;
            if (feedback && feedback.classList.contains("invalid-feedback")) {
              feedback.remove();
            }
            console.log(`[Validation] Cleared variant image grid error for ${variantImageGrid.closest('.variant-item').id}.`);
          }
        }
      }
    }

    clearSpecificValidationError(element) {
      console.log(`[Validation] Clearing specific error for: ${element.id || element.className}`);
      if (element.classList.contains("is-invalid")) {
        element.classList.remove("is-invalid");
      }
      const feedback = element.nextElementSibling;
      if (feedback && feedback.classList.contains("invalid-feedback")) {
        feedback.remove();
      }
    }


    // --- Save Logic ---
    async handleSave(e) {
      e.preventDefault();
      console.log("[Save] Save button clicked. Starting validation process.");
      const originalButtonText = this.elements.saveButton.textContent;
      this.elements.saveButton.textContent = "Đang lưu...";
      this.elements.saveButton.disabled = true;

      this.clearAllValidationErrors();
      this.validationErrors = [];

      // --- Validate Product Info ---
      if (!this.elements.productName.value.trim()) {
        this.addValidationError(this.elements.productName, "Tên sản phẩm là bắt buộc.");
      }
      if (!this.elements.productDescription.value.trim()) {
        this.addValidationError(this.elements.productDescription, "Mô tả sản phẩm là bắt buộc.");
      }
      if (!this.elements.productCategory.value) {
        this.addValidationError(this.elements.productCategory, "Danh mục là bắt buộc.");
      }
      if (!this.elements.productStatus.value) {
        this.addValidationError(this.elements.productStatus, "Trạng thái là bắt buộc.");
      }

      // Validate Main Image
      console.log(`[Save Validation] Main image file: ${this.mainImageFile ? this.mainImageFile.name : 'None'}, Preview display: ${this.elements.mainImagePreviewContainer.style.display}`);
      if (!this.mainImageFile && this.elements.mainImagePreviewContainer.style.display === "none") {
        this.addValidationError(this.elements.mainImageUploadZone, "Ảnh chính sản phẩm là bắt buộc.");
      }

      // Validate Rooms
      const room_ids = [...this.elements.productRooms.selectedOptions]
        .map((opt) => opt.value)
        .filter((val) => val);
      if (room_ids.length === 0) {
        this.addValidationError(this.elements.productRooms, "Vui lòng chọn ít nhất một phòng.");
      }

      // Validate Dynamic Attributes
      const dynamicAttributeInputs = document.querySelectorAll(".dynamic-attribute");
      const attributes = [];
      dynamicAttributeInputs.forEach((input) => {
        const attribute_id = input.dataset.attributeId;
        const valueType = input.dataset.valueType;
        let value = input.value.trim();
        let material_id = null;

        if (valueType === "material_id") {
          material_id = value;
          value = null;
        } else {
          if (input.type === "number") {
            value = value === "" ? null : parseFloat(value);
          } else {
            value = value === "" ? null : value;
          }
        }

        if (input.hasAttribute("required") && (value === null || value === "" || material_id === null || material_id === "")) {
          this.addValidationError(input, `Thông tin "${input.previousElementSibling.textContent.trim().replace('*', '')}" là bắt buộc.`);
        }

        if (attribute_id) {
          attributes.push({
            attribute_id: parseInt(attribute_id),
            value: value,
            material_id: material_id,
          });
        }
      });
      console.log("[Save Validation] Dynamic attributes collected:", attributes);


      // Validate Variants
      const variantElements = [...document.querySelectorAll(".variant-item")].filter(
        (item) => item.style.display !== "none" && item.id !== "variantTemplate"
      );
      console.log(`[Save Validation] Found ${variantElements.length} visible variants.`);

      if (variantElements.length === 0) {
        const sectionTitle = [...document.querySelectorAll(".section-title")].find((el) =>
          el.textContent.includes("Biến thể")
        );
        this.addValidationError(
          sectionTitle || this.elements.addVariantBtn,
          "Sản phẩm phải có ít nhất 1 biến thể!"
        );
      }

      const variantsToSubmit = [];
      for (const item of variantElements) {
        console.log(`[Save Validation] Validating variant: ${item.id}`);
        const color_id_el = item.querySelector(".variant-color");
        const variant_slug_el = item.querySelector(".variant-slug");
        const quantity_el = item.querySelector(".variant-quantity");
        const price_el = item.querySelector(".variant-price");
        const price_sale_el = item.querySelector(".variant-sale-price");

        if (!color_id_el.value) {
          this.addValidationError(color_id_el, "Màu sắc là bắt buộc.");
        }

        if (isNaN(parseInt(quantity_el.value)) || parseInt(quantity_el.value) < 0) {
          this.addValidationError(quantity_el, "Số lượng không hợp lệ.");
        }
        if (isNaN(parseFloat(price_el.value)) || parseFloat(price_el.value) < 0) {
          this.addValidationError(price_el, "Giá là bắt buộc.");
        }

        // Validate Variant Images
        const variantImageGrid = item.querySelector(".variant-image-grid");
        const list_image_items_loaded = [...item.querySelectorAll(".variant-image-item.loaded")];
        console.log(`[Save Validation:${item.id}] Loaded variant images: ${list_image_items_loaded.length}`);
        if (list_image_items_loaded.length === 0) {
          this.addValidationError(variantImageGrid, "Cần ít nhất 1 ảnh cho biến thể.");
        }

        variantsToSubmit.push({
          color_id: color_id_el.value,
          variant_slug: variant_slug_el.value.trim(),
          quantity: parseInt(quantity_el.value),
          price: parseFloat(price_el.value),
          price_sale: parseFloat(price_sale_el.value) || null,
          list_image_files: list_image_items_loaded.map(imgBox => imgBox.querySelector('input[type="file"]').files[0]), // Store file objects temporarily
        });
      }

      // If there are validation errors, stop and show them
      if (this.validationErrors.length > 0) {
        console.warn("[Save] Validation errors found. Stopping save process.", this.validationErrors);
        // Scroll to the first error
        this.validationErrors[0].element.scrollIntoView({
          behavior: "smooth",
          block: "center",
        });
        // Show toasts with a delay
        let delay = 0;
        for (const error of this.validationErrors) {
          setTimeout(() => {
            showToast(error.message, "danger");
          }, delay);
          delay += 500;
        }

        this.elements.saveButton.textContent = originalButtonText;
        this.elements.saveButton.disabled = false;
        return;
      }

      // --- Proceed with image uploads and API submission if no client-side validation errors ---
      console.log("[Save] Client-side validation passed. Proceeding with image uploads.");
      let main_image_url = null;
      try {
        if (this.mainImageFile) {
          main_image_url = await uploadImage(this.mainImageFile, "SonaSpace/Product", "main");
          if (!main_image_url) {
            throw new Error("Không thể tải ảnh chính lên.");
          }
        }
      } catch (uploadError) {
        console.error("[Save] Failed to upload main image:", uploadError);
        showToast("Lỗi khi tải ảnh chính: " + uploadError.message, "danger");
        this.elements.saveButton.textContent = originalButtonText;
        this.elements.saveButton.disabled = false;
        return;
      }

      // Upload variant images
      const finalVariants = [];
      for (const variantData of variantsToSubmit) {
        const list_image_urls = [];
        console.log(`[Save] Uploading images for variant: ${variantData.color_id}`);
        for (const file of variantData.list_image_files) {
          try {
            const url = await uploadImage(file, "SonaSpace/Product", "variant");
            if (url) {
              list_image_urls.push(url);
            } else if (file) {
              throw new Error("Không thể lấy URL ảnh biến thể sau khi tải lên.");
            }
          } catch (uploadError) {
            console.error("[Save] Failed to upload variant image:", uploadError);
            showToast("Lỗi khi tải ảnh biến thể: " + uploadError.message, "danger");
            this.elements.saveButton.textContent = originalButtonText;
            this.elements.saveButton.disabled = false;
            return;
          }
        }
        finalVariants.push({
          color_id: variantData.color_id,
          variant_slug: variantData.variant_slug,
          quantity: variantData.quantity,
          price: variantData.price,
          price_sale: variantData.price_sale,
          list_image: list_image_urls,
        });
      }
      console.log("[Save] All images uploaded. Final variants data:", finalVariants);

      // Construct final product data
      const productData = {
        name: this.elements.productName.value.trim(),
        slug: this.elements.productSlug.value.trim(),
        description: this.elements.productDescription.value.trim(),
        category_id: parseInt(this.elements.productCategory.value),
        status: parseInt(this.elements.productStatus.value),
        main_image: main_image_url,
        room_ids: room_ids.map(Number),
        attributes: attributes,
        variants: finalVariants,
      };

      console.log("[Save] Product data to send to API:", productData);

      try {
        const res = await fetch(`${API_URL}/products/add`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(productData),
        });

        const data = await res.json();
        if (!res.ok) {
          console.error("[Save] Server responded with an error:", data);
          if (data.errors && Array.isArray(data.errors)) {
            // Re-add validation errors from server response
            data.errors.forEach(({ field, message }) => {
              // Find corresponding DOM element and apply error
              let targetElement = null;
              if (field === "name") targetElement = this.elements.productName;
              else if (field === "slug") targetElement = this.elements.productSlug;
              else if (field === "description") targetElement = this.elements.productDescription;
              else if (field === "category_id") targetElement = this.elements.productCategory;
              else if (field === "status") targetElement = this.elements.productStatus;
              else if (field === "main_image") targetElement = this.elements.mainImageUploadZone;
              else if (field === "room_ids") targetElement = this.elements.productRooms;
              else if (field.startsWith("attributes")) {
                const attrIdMatch = field.match(/attributes\[(\d+)\]\.(.+)/);
                if (attrIdMatch) {
                  const attrInput = document.querySelector(`.dynamic-attribute[data-attribute-id="${attrIdMatch[1]}"]`);
                  if (attrInput) targetElement = attrInput;
                } else {
                  targetElement = this.elements.dynamicAttributesContainer; // Fallback
                }
              }
              else if (field.startsWith("variants[")) {
                const match = field.match(/variants\[(\d+)\]\.(.+)/);
                if (match) {
                  const idx = parseInt(match[1]);
                  const key = match[2];
                  const visibleVariants = [...document.querySelectorAll(".variant-item")].filter(
                    (v) => v.style.display !== "none" && v.id !== "variantTemplate"
                  );
                  const variantEl = visibleVariants[idx];

                  if (variantEl) {
                    if (key === "color_id") targetElement = variantEl.querySelector(".variant-color");
                    else if (key === "variant_slug") targetElement = variantEl.querySelector(".variant-slug");
                    else if (key === "quantity") targetElement = variantEl.querySelector(".variant-quantity");
                    else if (key === "price") targetElement = variantEl.querySelector(".variant-price");
                    else if (key === "list_image") targetElement = variantEl.querySelector(".variant-image-grid");
                  }
                }
              }

              if (targetElement) {
                this.addValidationError(targetElement, message);
              } else {
                showToast(`Lỗi trường '${field}': ${message}`, "danger"); // Fallback toast
              }
            });
            // Scroll to the first error after server validation
            if (this.validationErrors.length > 0) {
              this.validationErrors[0].element.scrollIntoView({
                behavior: "smooth",
                block: "center",
              });
              let delay = 0;
              for (const error of this.validationErrors) {
                setTimeout(() => {
                  showToast(error.message, "danger");
                }, delay);
                delay += 500;
              }
            }

          } else {
            showToast(data.error || "Lỗi không xác định khi tạo sản phẩm.", "danger");
          }

          this.elements.saveButton.textContent = originalButtonText;
          this.elements.saveButton.disabled = false;
          return;
        }

        console.log("[Save] Product created successfully!");
        showToast("Tạo sản phẩm thành công");
        setTimeout(() => {
          window.location.href = "/dashboard/products";
        }, 1000);
      } catch (error) {
        console.error("[Save] Error connecting to server or unexpected error:", error);
        showToast("Lỗi khi kết nối đến máy chủ: " + error.message, "danger");

        this.elements.saveButton.textContent = originalButtonText;
        this.elements.saveButton.disabled = false;
      }
    }
  }

  // Initialize the form manager when the DOM is fully loaded
  document.addEventListener("DOMContentLoaded", () => {
    console.log("[DOMContentLoaded] Initializing ProductFormManager.");
    const productForm = new ProductFormManager();
    productForm.initializeForm();

    // Initial setup for existing variants (if any, e.g., on edit page)
    // This loop ensures that if variants are pre-loaded (e.g., from a database for an edit form),
    // their event listeners are correctly attached.
    document.querySelectorAll(".variant-item").forEach((variant) => {
      if (variant.id !== "variantTemplate") {
        console.log(`[DOMContentLoaded] Setting up events for pre-existing variant: ${variant.id}`);
        productForm.setupVariantEvents(variant);
      }
    });
  });
</script>